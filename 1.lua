 local function KolOS_main()package.path=package.path..";KolOS/?.lua" local GUI={}GUI.__index=GUI local function components_Button()local Button={}Button.__index=Button function Button:new(x,y,label,callback,bgColor,textColor,width,height)local obj=setmetatable({},self)obj.x=x obj.y=y obj.label=label obj.callback=callback or function()end obj.bgColor=bgColor or colors.gray obj.textColor=textColor or colors.white obj.width=width or#label+2 obj.height=height or 1 return obj end function Button:setPosition(x,y)local winWidth,winHeight=self.gui.win.getSize()self.x=math.max(1,math.min(x,winWidth))self.y=math.max(1,math.min(y,winHeight))end function Button:setSize(width,height)local winWidth,winHeight=self.gui.win.getSize()self.width=math.max(1,math.min(width,winWidth-self.x+1))self.height=math.max(1,math.min(height,winHeight-self.y+1))end function Button:addCallback(callback)self.callback=callback or function()end end function Button:draw(canvas)for i=0,self.height-1 do local y=self.y+i for j=0,self.width-1 do local x=self.x+j if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor if i==math.floor(self.height/2)and j>=math.floor((self.width-#self.label)/2)and j<math.floor((self.width-#self.label)/2)+#self.label then canvas[y][x].char=self.label:sub(j-math.floor((self.width-#self.label)/2)+1,j-math.floor((self.width-#self.label)/2)+1)else canvas[y][x].char=" " end canvas[y][x].charColor=self.textColor end end end end function Button:handleClick(mx,my)if mx>=self.x and mx<self.x+self.width and my>=self.y and my<self.y+self.height then self.callback()end end return Button end local Button=components_Button()local function components_Input()local Input={}Input.__index=Input function Input:new(x,y,width,maxLength,bgColor,textColor)local obj=setmetatable({},self)obj.x=x obj.y=y obj.width=width obj.text="" obj.active=false obj.cursorPos=0 obj.scrollOffset=0 obj.maxLength=maxLength or width obj.bgColor=bgColor or colors.white obj.textColor=textColor or colors.black return obj end function Input:setPosition(x,y)local winWidth,winHeight=self.gui.win.getSize()self.x=math.max(1,math.min(x,winWidth))self.y=math.max(1,math.min(y,winHeight))end function Input:setSize(width)local winWidth,_=self.gui.win.getSize()self.width=math.max(1,math.min(width,winWidth-self.x+1))end function Input:draw(canvas)for i=1,self.width do local x=self.x+i-1 local y=self.y if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor local char=self.text:sub(self.scrollOffset+i,self.scrollOffset+i)canvas[y][x].char=char~="" and char or " " canvas[y][x].charColor=self.textColor end end if self.active then local cursorX=self.x+self.cursorPos-self.scrollOffset if canvas[self.y]and canvas[self.y][cursorX]then canvas[self.y][cursorX].bgColor=self.textColor canvas[self.y][cursorX].charColor=self.bgColor local char=self.text:sub(self.cursorPos+1,self.cursorPos+1)canvas[self.y][cursorX].char=char~="" and char or "_" end end end function Input:handleClick(mx,my)if mx>=self.x and mx<self.x+self.width and my==self.y then self.active=true self.cursorPos=math.min(mx-self.x+self.scrollOffset,#self.text)else self.active=false end end function Input:handleInput(event,param)if self.active and event=="char" then if#self.text<self.maxLength then self.text=self.text:sub(1,self.cursorPos)..param..self.text:sub(self.cursorPos+1)self.cursorPos=self.cursorPos+1 if self.cursorPos>self.scrollOffset+self.width then self.scrollOffset=self.scrollOffset+1 end end elseif self.active and event=="key" then if param==keys.backspace then if self.cursorPos>0 then self.text=self.text:sub(1,self.cursorPos-1)..self.text:sub(self.cursorPos+1)self.cursorPos=self.cursorPos-1 if self.cursorPos<self.scrollOffset then self.scrollOffset=self.scrollOffset-1 end end elseif param==keys.enter then self.active=false elseif param==keys.left then if self.cursorPos>0 then self.cursorPos=self.cursorPos-1 if self.cursorPos<self.scrollOffset then self.scrollOffset=self.scrollOffset-1 end end elseif param==keys.right then if self.cursorPos<#self.text then self.cursorPos=self.cursorPos+1 if self.cursorPos>self.scrollOffset+self.width then self.scrollOffset=self.scrollOffset+1 end end end end end return Input end local Input=components_Input()local function components_Label()local Label={}Label.__index=Label function Label:new(x,y,text,textColor)local obj=setmetatable({},self)obj.x=x obj.y=y obj.text=text obj.textColor=textColor or colors.white return obj end function Label:setPosition(x,y)local winWidth,winHeight=self.gui.win.getSize()self.x=math.max(1,math.min(x,winWidth))self.y=math.max(1,math.min(y,winHeight))end function Label:setSize(width)local winWidth,_=self.gui.win.getSize()self.width=math.max(1,math.min(width,winWidth-self.x+1))end function Label:draw(canvas)for i=1,#self.text do local x=self.x+i-1 local y=self.y if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=colors.black canvas[y][x].char=self.text:sub(i,i)canvas[y][x].charColor=self.textColor end end end function Label:setText(newText)self.text=newText if self.gui then self.gui:draw()end end return Label end local Label=components_Label()local function components_KeyHandler()local KeyHandler={}KeyHandler.__index=KeyHandler function KeyHandler:new()local obj=setmetatable({},self)obj.keyMappings={}return obj end function KeyHandler:registerKey(key,action)self.keyMappings[key]=action end function KeyHandler:handleKey(key)if self.keyMappings[key]then self.keyMappings[key]()end end return KeyHandler end local KeyHandler=components_KeyHandler()local function components_Textarea()local Textarea={}Textarea.__index=Textarea function Textarea:new(x,y,width,height,bgColor,textColor)local obj=setmetatable({},self)obj.x=x obj.y=y obj.width=width obj.height=height obj.list={}obj.textList={}obj.active=false obj.bgColor=bgColor or colors.white obj.textColor=textColor or colors.black obj.scrollOffset=0 return obj end function Textarea:setPosition(x,y)local winWidth,winHeight=self.gui.win.getSize()self.x=math.max(1,math.min(x,winWidth))self.y=math.max(1,math.min(y,winHeight))end function Textarea:setSize(width,height)local winWidth,winHeight=self.gui.win.getSize()self.width=math.max(1,math.min(width,winWidth-self.x+1))self.height=math.max(1,math.min(height,winHeight-self.y+1))self:updateTextList()end function Textarea:draw(canvas)for i=1,self.height do local y=self.y+i-1 local line=self.textList[i+self.scrollOffset]or "" for j=1,self.width do local x=self.x+j-1 if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor canvas[y][x].char=line:sub(j,j)~="" and line:sub(j,j)or " " canvas[y][x].charColor=self.textColor end end end end function Textarea:updateTextList()self.textList={}for _,line in ipairs(self.list)do while#line>self.width do table.insert(self.textList,line:sub(1,self.width))line=line:sub(self.width+1)end table.insert(self.textList,line)end self.scrollOffset=math.max(0,#self.textList-self.height)end function Textarea:setText(newText)self.list={}for line in newText:gmatch("[^\r\n]+")do table.insert(self.list,line)end self:updateTextList()if self.gui then self.gui:draw()end end function Textarea:addLine(line)table.insert(self.list,line)self:updateTextList()if self.gui then self.gui:draw()end end function Textarea:scrollUp()if self.scrollOffset>0 then self.scrollOffset=self.scrollOffset-1 if self.gui then self.gui:draw()end end end function Textarea:scrollDown()if self.scrollOffset<#self.textList-self.height then self.scrollOffset=self.scrollOffset+1 if self.gui then self.gui:draw()end end end function Textarea:isMouseOver(mx,my)return mx>=self.x and mx<self.x+self.width and my>=self.y and my<self.y+self.height end return Textarea end local Textarea=components_Textarea()local function components_Rect()local Rect={}Rect.__index=Rect function Rect:new(x,y,width,height,bgColor,fill,char,charColor)local obj=setmetatable({},self)obj.x=x obj.y=y obj.width=width obj.height=height obj.bgColor=bgColor or colors.gray obj.fill=fill or false obj.char=char or " " obj.charColor=charColor or colors.white return obj end function Rect:setPosition(x,y)local winWidth,winHeight=self.gui.win.getSize()self.x=math.max(1,math.min(x,winWidth))self.y=math.max(1,math.min(y,winHeight))end function Rect:setSize(width,height)local winWidth,winHeight=self.gui.win.getSize()self.width=math.max(1,math.min(width,winWidth-self.x+1))self.height=math.max(1,math.min(height,winHeight-self.y+1))end function Rect:draw(canvas)for i=0,self.height-1 do for j=0,self.width-1 do if self.fill or i==0 or i==self.height-1 or j==0 or j==self.width-1 then local x=self.x+j local y=self.y+i if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor canvas[y][x].char=self.char canvas[y][x].charColor=self.charColor end end end end end return Rect end local Rect=components_Rect()local function components_Dropdown()local Dropdown={}Dropdown.__index=Dropdown function Dropdown:new(x,y,width,items,bgColor,textColor)local obj=setmetatable({},self)obj.x=x obj.y=y obj.width=width obj.items=items or{}obj.selectedIndex=1 obj.expanded=false obj.bgColor=bgColor or colors.gray obj.textColor=textColor or colors.white obj.scrollOffset=0 return obj end function Dropdown:setPosition(x,y)local winWidth,winHeight=self.gui.win.getSize()self.x=math.max(1,math.min(x,winWidth))self.y=math.max(1,math.min(y,winHeight))end function Dropdown:setSize(width)local winWidth,_=self.gui.win.getSize()self.width=math.max(1,math.min(width,winWidth-self.x+1))end function Dropdown:draw(canvas)local function truncateText(text,maxLength)if#text<=maxLength then return text else local halfLength=math.floor((maxLength-2)/2)return text:sub(1,halfLength)..".."..text:sub(-halfLength)end end for i=1,self.width do local x=self.x+i-1 local y=self.y if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor if i==self.width then canvas[y][x].char="V" else local truncatedItem=truncateText(self.items[self.selectedIndex],self.width-1)local char=truncatedItem:sub(i,i)canvas[y][x].char=char~="" and char or " " end canvas[y][x].charColor=self.textColor end end if self.expanded then local maxVisibleItems=math.min(#self.items,5)for i=1,maxVisibleItems do local itemIndex=i+self.scrollOffset local y=self.y+i for j=1,self.width do local x=self.x+j-1 if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor local truncatedItem=truncateText(self.items[itemIndex],self.width)local char=truncatedItem:sub(j,j)canvas[y][x].char=char~="" and char or " " canvas[y][x].charColor=self.textColor end end end end end function Dropdown:handleClick(mx,my)if mx>=self.x and mx<self.x+self.width and my==self.y then self.expanded=not self.expanded elseif self.expanded and mx>=self.x and mx<self.x+self.width then local winWidth,winHeight=self.gui.win.getSize()local maxVisibleItems=math.min(#self.items,5)local startY=self.y+1 if self.y+maxVisibleItems>winHeight then startY=self.y-maxVisibleItems end if my>=startY and my<startY+maxVisibleItems then self.selectedIndex=my-startY+1+self.scrollOffset self.expanded=false else self.expanded=false end else self.expanded=false end end function Dropdown:handleScroll(direction)if self.expanded then if direction==0 and self.scrollOffset>0 then self.scrollOffset=self.scrollOffset-1 elseif direction==1 and self.scrollOffset<#self.items-5 then self.scrollOffset=self.scrollOffset+1 end end end function Dropdown:handleKey(key)if self.expanded then if key==keys.up and self.scrollOffset>0 then self.scrollOffset=self.scrollOffset-1 elseif key==keys.down and self.scrollOffset<#self.items-5 then self.scrollOffset=self.scrollOffset+1 elseif key==keys.enter then self.selectedIndex=self.scrollOffset+1 self.expanded=false end end end function Dropdown:isExpanded()return self.expanded end function Dropdown:getSelectedOption()return self.items[self.selectedIndex]end return Dropdown end local Dropdown=components_Dropdown()local function components_Switch()local Switch={}Switch.__index=Switch function Switch:new(x,y,state,callback,textColor,activeText,inactiveText,activeBgColor,inactiveBgColor,activeTextColor,inactiveTextColor)local obj=setmetatable({},self)obj.x=x obj.y=y obj.state=state or false obj.callback=callback obj.textColor=textColor or colors.white obj.activeBgColor=activeBgColor or colors.green obj.inactiveBgColor=inactiveBgColor or colors.red obj.activeTextColor=activeTextColor or colors.white obj.inactiveTextColor=inactiveTextColor or colors.white obj.activeText=activeText or "[ON]" obj.inactiveText=inactiveText or "[OFF]" return obj end function Switch:draw(canvas)self.width=self.state and#self.activeText or#self.inactiveText for i=0,self.width-1 do local x=self.x+i local y=self.y if canvas[y]and canvas[y][x]then if self.state then canvas[y][x].bgColor=self.activeBgColor canvas[y][x].charColor=self.activeTextColor canvas[y][x].char=self.activeText:sub(i+1,i+1)else canvas[y][x].bgColor=self.inactiveBgColor canvas[y][x].charColor=self.inactiveTextColor canvas[y][x].char=self.inactiveText:sub(i+1,i+1)end end end end function Switch:handleClick(x,y)if x>=self.x and x<self.x+self.width and y==self.y then self.state=not self.state if self.callback then self.callback(self.state)end end end function Switch:setColors(activeBgColor,inactiveBgColor,activeTextColor,inactiveTextColor)self.activeBgColor=activeBgColor self.inactiveBgColor=inactiveBgColor self.activeTextColor=activeTextColor self.inactiveTextColor=inactiveTextColor end function Switch:setActiveText(text)self.activeText=text end function Switch:setInactiveText(text)self.inactiveText=text end return Switch end local Switch=components_Switch()local function components_Line()local Line={}Line.__index=Line function Line:new(x1,y1,x2,y2,color,bgColor,char)local obj=setmetatable({},self)obj.x1=x1 obj.y1=y1 obj.x2=x2 obj.y2=y2 obj.color=color or colors.white obj.bgColor=bgColor or colors.black obj.char=char or "-" return obj end function Line:draw(canvas)if self.y1==self.y2 then for x=self.x1,self.x2 do if canvas[self.y1]and canvas[self.y1][x]then canvas[self.y1][x].bgColor=self.bgColor canvas[self.y1][x].char=self.char canvas[self.y1][x].charColor=self.color end end elseif self.x1==self.x2 then for y=self.y1,self.y2 do if canvas[y]and canvas[y][self.x1]then canvas[y][self.x1].bgColor=self.bgColor canvas[y][self.x1].char=self.char canvas[y][self.x1].charColor=self.color end end else local dx=math.abs(self.x2-self.x1)local dy=math.abs(self.y2-self.y1)local sx=self.x1<self.x2 and 1 or-1 local sy=self.y1<self.y2 and 1 or-1 local err=dx-dy local x=self.x1 local y=self.y1 while true do if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor canvas[y][x].char=self.char canvas[y][x].charColor=self.color end if x==self.x2 and y==self.y2 then break end local e2=2*err if e2>-dy then err=err-dy x=x+sx end if e2<dx then err=err+dx y=y+sy end end end end return Line end local Line=components_Line()local function components_Circle()local Circle={}Circle.__index=Circle function Circle:new(x1,y1,x2,y2,color,fill,char,charColor)local obj=setmetatable({},self)obj.x1=x1 obj.y1=y1 obj.x2=x2 obj.y2=y2 obj.color=color obj.fill=fill or false obj.char=char or " " obj.charColor=charColor or colors.white obj.pixels={}obj:update()return obj end function Circle:update()local centerX=(self.x1+self.x2)/2 local centerY=(self.y1+self.y2)/2 local radiusX=math.abs(self.x2-self.x1)/2 local radiusY=math.abs(self.y2-self.y1)/2 local circumference=2*math.pi*math.min(radiusX,radiusY)local step=1/circumference self.pixels={}for theta=0,math.pi/2,step do local x=centerX+radiusX*math.cos(theta)local y=centerY+radiusY*math.sin(theta)table.insert(self.pixels,{math.floor(x+0.5),math.floor(y+0.5)})end local quarterPixels={}for _,pixel in ipairs(self.pixels)do table.insert(quarterPixels,{2*centerX-pixel[1],pixel[2]})table.insert(quarterPixels,{pixel[1],2*centerY-pixel[2]})table.insert(quarterPixels,{2*centerX-pixel[1],2*centerY-pixel[2]})end for _,pixel in ipairs(quarterPixels)do table.insert(self.pixels,pixel)end if self.fill then for y=self.y1,self.y2 do for x=self.x1,self.x2 do local dx=(x-centerX)/radiusX local dy=(y-centerY)/radiusY if dx*dx+dy*dy<=1 then table.insert(self.pixels,{x,y})end end end end end function Circle:draw(canvas)self.canvas=canvas for _,pixel in ipairs(self.pixels)do local x=pixel[1]local y=pixel[2]if self.canvas[y]and self.canvas[y][x]then self.canvas[y][x].bgColor=self.color self.canvas[y][x].char=self.char self.canvas[y][x].charColor=self.charColor end end end return Circle end local Circle=components_Circle()function GUI:new(x,y,width,height,parent)local termWidth,termHeight=term.getSize()x=x or 0 y=y or 0 width=width or termWidth height=height or termHeight local obj=setmetatable({},self)obj.win=window.create(parent or term.current(),x,y,width,height)obj.components={}obj.keyHandler=KeyHandler:new()obj.canvas={}for i=1,height do obj.canvas[i]={}for j=1,width do obj.canvas[i][j]={bgColor=colors.black,char=" ",charColor=colors.white}end end return obj end function GUI:addLabel(x,y,text,textColor)local label=Label:new(x,y,text,textColor)label.gui=self table.insert(self.components,label)return label end function GUI:addButton(x,y,label,callback,bgColor,textColor,width,height)local button=Button:new(x,y,label,callback,bgColor,textColor,width,height)button.gui=self table.insert(self.components,button)return button end function GUI:addInput(x,y,width,maxLength,bgColor,textColor)local input=Input:new(x,y,width,maxLength,bgColor,textColor)input.gui=self table.insert(self.components,input)return input end function GUI:addTextarea(x,y,width,height,bgColor,textColor)local textarea=Textarea:new(x,y,width,height,bgColor,textColor)textarea.gui=self table.insert(self.components,textarea)return textarea end function GUI:addRect(x,y,width,height,bgColor,fill,char,charColor)local rect=Rect:new(x,y,width,height,bgColor,fill,char,charColor)rect.gui=self table.insert(self.components,rect)return rect end function GUI:addDropdown(x,y,width,items,bgColor,textColor)local dropdown=Dropdown:new(x,y,width,items,bgColor,textColor)dropdown.gui=self table.insert(self.components,dropdown)return dropdown end function GUI:addSwitch(x,y,state,callback,textColor,activeText,inactiveText,activeBgColor,inactiveBgColor,activeTextColor,inactiveTextColor)local switch=Switch:new(x,y,state,callback,textColor,activeText,inactiveText,activeBgColor,inactiveBgColor,activeTextColor,inactiveTextColor)switch.gui=self table.insert(self.components,switch)return switch end function GUI:addLine(x1,y1,x2,y2,color,bgColor,char)local line=Line:new(x1,y1,x2,y2,color,bgColor,char)line.gui=self table.insert(self.components,line)return line end function GUI:addCircle(x1,y1,x2,y2,color,fill,char,charColor)local circle=Circle:new(x1,y1,x2,y2,color,fill,char,charColor)circle.gui=self table.insert(self.components,circle)return circle end function GUI:addKeyHandler()return self.keyHandler end function GUI:draw()local win=self.win for y,row in ipairs(self.canvas)do for x,_ in ipairs(row)do self.canvas[y][x]={bgColor=colors.black,char=" ",charColor=colors.white}end end for _,comp in ipairs(self.components)do if comp.draw then comp:draw(self.canvas)end end for y,row in ipairs(self.canvas)do for x,pixel in ipairs(row)do win.setCursorPos(x,y)win.setBackgroundColor(pixel.bgColor)win.setTextColor(pixel.charColor)win.write(pixel.char)end end win.redraw()end function GUI:handleClick(x,y)for _,comp in ipairs(self.components)do if getmetatable(comp)==Dropdown and comp:isExpanded()then comp:handleClick(x,y)return end end for _,comp in ipairs(self.components)do if comp.handleClick then comp:handleClick(x,y)end end end function GUI:handleKey(key)for _,comp in ipairs(self.components)do if getmetatable(comp)==Input and comp.active then return elseif getmetatable(comp)==Dropdown and comp.expanded then comp:handleKey(key)return end end self.keyHandler:handleKey(key)end function GUI:update(event,param1,param2,param3)if event=="mouse_click" then self:handleClick(param2,param3)elseif event=="key" or event=="char" then self:handleKey(param1)for _,comp in ipairs(self.components)do if comp.handleInput then comp:handleInput(event,param1)elseif getmetatable(comp)==Textarea then if param1==keys.up then comp:scrollUp()elseif param1==keys.down then comp:scrollDown()end end end elseif event=="mouse_scroll" then for _,comp in ipairs(self.components)do if getmetatable(comp)==Dropdown and comp.expanded then comp:handleScroll(param1)elseif getmetatable(comp)==Textarea and comp:isMouseOver(param2,param3)then if param1==0 then comp:scrollUp()elseif param1==1 then comp:scrollDown()end end end end self:draw()end function GUI:run(...)local functions={...}self:draw()parallel.waitForAny(function()while true do local event,param1,param2,param3=os.pullEvent()self:update(event,param1,param2,param3)end end,table.unpack(functions))end return GUI end local GUI2=KolOS_main()print(package.path)local function main()local gui=GUI2:new(1,1,51,19)local textarea=gui:addTextarea(2,10,30,3)textarea:setText("This is a      textarea.\nYou, can.. --type multiple lines here.")local label=gui:addLabel(2,2,"Label Hello, World!")gui:addButton(2,6,"Click Me",function()textarea:setSize(textarea.width+1,textarea.height+1)end)local input2=gui:addInput(2,8,20)input2.text="Type here" local rect=gui:addRect(35,2,15,10,colors.red,true,"-",colors.yellow)local circle=gui:addCircle(36,3,48,10,colors.white,true," ",colors.yellow)local dropdown=gui:addDropdown(2,4,20,{"Optionssssssssssssssssssssssssss 1","Option 2","Option 3","Option 4","Option 5","Option 6"})local switch=gui:addSwitch(2,14,false,function(state)if state then label:setText("Switch is ON")else label:setText("Switch is OFF")end end)local line=gui:addLine(2,16,20,18,colors.yellow,colors.black,"=")local keyHandler=gui:addKeyHandler()keyHandler:registerKey(keys.q,function()textarea:setSize(textarea.width-1,textarea.height-1)end)while true do local event,param1,param2,param3=os.pullEvent()l={}for index,value in ipairs({event,param1,param2,param3})do table.insert(l,tostring(value))end textarea:addLine(table.concat(l,' '))gui:update(event,param1,param2,param3)end end main()