 local function KolOS()package.path=package.path..";KolOS/?.lua" local GUI={}GUI.__index=GUI local function components_Button()local Button={}Button.__index=Button function Button:new(x,y,label,callback,bgColor,textColor,width,height)if type(x)=="table" then local params=x x=params.x y=params.y label=params.label callback=params.callback bgColor=params.bgColor textColor=params.textColor width=params.width height=params.height end local obj=setmetatable({},self)obj.x=x or 0 obj.y=y or 0 obj.label=label or "" obj.callback=callback or{}obj.bgColor=bgColor or colors.gray obj.textColor=textColor or colors.white obj.width=width or#obj.label+2 obj.height=height or 1 return obj end function Button:setPosition(x,y)self.x=x or self.x self.y=y or self.y return self end function Button:setSize(width,height)self.width=width or self.width self.height=height or self.height return self end function Button:setLabel(label,width,height)self.label=label or self.label self.width=width or#self.label+2 self.height=height or 1 return self end function Button:setBgColor(bgColor,textColor)self.bgColor=bgColor or self.bgColor self.textColor=textColor or self.textColor return self end function Button:addCallback(callback)table.insert(self.callback,callback or function()end)return self end function Button:draw(canvas)for i=0,self.height-1 do local y=self.y+i for j=0,self.width-1 do local x=self.x+j if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor if i==math.floor(self.height/2)and j>=math.floor((self.width-#self.label)/2)and j<math.floor((self.width-#self.label)/2)+#self.label then canvas[y][x].char=self.label:sub(j-math.floor((self.width-#self.label)/2)+1,j-math.floor((self.width-#self.label)/2)+1)else canvas[y][x].char=" " end canvas[y][x].charColor=self.textColor end end end end function Button:handleClick(mx,my)if mx>=self.x and mx<self.x+self.width and my>=self.y and my<self.y+self.height then for _,cb in ipairs(self.callback)do cb()end end end return Button end local Button=components_Button()local function components_Input()local Input={}Input.__index=Input function Input:new(x,y,width,maxLength,bgColor,textColor,replaceChar,history,completeFn,default,callback,deactivateOnEnter)if type(x)=="table" then local params=x x=params.x y=params.y width=params.width maxLength=params.maxLength bgColor=params.bgColor textColor=params.textColor replaceChar=params.replaceChar history=params.history completeFn=params.completeFn default=params.default callback=params.callback deactivateOnEnter=params.deactivateOnEnter end local obj=setmetatable({},self)obj.x=x or 0 obj.y=y or 0 obj.width=width or 10 obj.text=default or "" obj.active=false obj.cursorPos=#obj.text obj.scrollOffset=0 obj.maxLength=maxLength or obj.width obj.bgColor=bgColor or colors.white obj.textColor=textColor or colors.black obj.replaceChar=replaceChar obj.history=history or{}obj.completeFn=completeFn obj.historyIndex=#obj.history+1 obj.completions={}obj.completionIndex=0 obj.callback=callback obj.deactivateOnEnter=deactivateOnEnter~=false return obj end function Input:setPosition(x,y)self.x=x or self.x self.y=y or self.y return self end function Input:setSize(width,maxLength)self.width=width or self.width self.maxLength=maxLength or self.maxLength return self end function Input:setColors(bgColor,textColor)self.bgColor=bgColor or self.bgColor self.textColor=textColor or self.textColor return self end function Input:setReplaceChar(replaceChar)self.replaceChar=replaceChar return self end function Input:setHistory(history)self.history=history or{}self.historyIndex=#self.history+1 return self end function Input:setCompleteFn(completeFn)self.completeFn=completeFn return self end function Input:setDefault(default)self.text=default or "" self.cursorPos=#self.text self.scrollOffset=0 return self end function Input:setCallback(callback)self.callback=callback return self end function Input:setDeactivateOnEnter(deactivateOnEnter)self.deactivateOnEnter=deactivateOnEnter return self end function Input:addHistory(item)table.insert(self.history,item)self.historyIndex=#self.history+1 return self end function Input:draw(canvas)for i=1,self.width do local x=self.x+i-1 local y=self.y if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor local char=self.text:sub(self.scrollOffset+i,self.scrollOffset+i)if self.replaceChar then char=char~="" and self.replaceChar or " " end canvas[y][x].char=char~="" and char or " " canvas[y][x].charColor=self.textColor end end if self.active then local cursorX=self.x+self.cursorPos-self.scrollOffset if canvas[self.y]and canvas[self.y][cursorX]then canvas[self.y][cursorX].bgColor=self.textColor canvas[self.y][cursorX].charColor=self.bgColor local char=self.text:sub(self.cursorPos+1,self.cursorPos+1)if self.replaceChar then char=char~="" and self.replaceChar or "_" end canvas[self.y][cursorX].char=char~="" and char or "_" end end if self.active and#self.completions>0 then local suggestion=self.completions[self.completionIndex]for i=1,#suggestion do local x=self.x+self.cursorPos-self.scrollOffset+i if canvas[self.y+1]and canvas[self.y+1][x]then canvas[self.y+1][x].bgColor=self.textColor canvas[self.y+1][x].char=suggestion:sub(i,i)canvas[self.y+1][x].charColor=self.bgColor end end end end function Input:handleClick(mx,my)if mx>=self.x and mx<self.x+self.width and my==self.y then self.active=true self.cursorPos=math.min(mx-self.x+self.scrollOffset,#self.text)else self.active=false end end function Input:updateCompletions()if self.completeFn then self.completions=self.completeFn(self.text:sub(1,self.cursorPos))or{}self.completionIndex=1 else self.completions={}self.completionIndex=0 end end function Input:handleInput(event,param)if self.active and event=="char" then self.historyIndex=#self.history+1 if#self.text<self.maxLength then self.text=self.text:sub(1,self.cursorPos)..param..self.text:sub(self.cursorPos+1)self.cursorPos=self.cursorPos+1 if self.cursorPos>self.scrollOffset+self.width then self.scrollOffset=self.scrollOffset+1 end end self:updateCompletions()elseif self.active and event=="key" then if param==keys.backspace then self.historyIndex=#self.history+1 if self.cursorPos>0 then self.text=self.text:sub(1,self.cursorPos-1)..self.text:sub(self.cursorPos+1)self.cursorPos=self.cursorPos-1 if self.cursorPos<self.scrollOffset then self.scrollOffset=self.scrollOffset-1 end end if#self.text==0 then self.completions={}self.completionIndex=0 else self:updateCompletions()end elseif param==keys.enter then table.insert(self.history,self.text)self.historyIndex=#self.history+1 if self.callback then self.callback(self.text)end self.text="" self.cursorPos=0 if self.deactivateOnEnter then self.active=false end elseif param==keys.left then if self.cursorPos>0 then self.cursorPos=self.cursorPos-1 if self.cursorPos<self.scrollOffset then self.scrollOffset=self.scrollOffset-1 end self:updateCompletions()end elseif param==keys.right then if self.cursorPos<#self.text then self.cursorPos=self.cursorPos+1 if self.cursorPos>self.scrollOffset+self.width then self.scrollOffset=self.scrollOffset+1 end self:updateCompletions()end elseif param==keys.up then if#self.completions>0 then self.completionIndex=(self.completionIndex-2)%#self.completions+1 elseif self.history and self.historyIndex>1 then self.historyIndex=self.historyIndex-1 self.text=self.history[self.historyIndex]or "" self.cursorPos=#self.text self.scrollOffset=math.max(0,self.cursorPos-self.width)end elseif param==keys.down then if#self.completions>0 then self.completionIndex=self.completionIndex%#self.completions+1 elseif self.history and self.historyIndex<#self.history then self.historyIndex=self.historyIndex+1 self.text=self.history[self.historyIndex]or "" self.cursorPos=#self.text self.scrollOffset=math.max(0,self.cursorPos-self.width)end elseif param==keys.tab and#self.completions>0 then local completion=self.completions[self.completionIndex]self.text=self.text:sub(1,self.cursorPos)..completion self.cursorPos=#self.text self.scrollOffset=math.max(0,self.cursorPos-self.width)self:updateCompletions()end end end return Input end local Input=components_Input()local function components_Label()local Label={}Label.__index=Label function Label:new(x,y,text,textColor,bgColor)if type(x)=="table" then local params=x x=params.x y=params.y text=params.text textColor=params.textColor bgColor=params.bgColor end local obj=setmetatable({},self)obj.x=x or 1 obj.y=y or 1 obj.text=text or "" obj.textColor=textColor or colors.white obj.bgColor=bgColor or colors.black return obj end function Label:setPosition(x,y)self.x=x or self.x self.y=y or self.y return self end function Label:setText(newText)self.text=newText if self.gui then self.gui:draw()end return self end function Label:setColors(textColor,bgColor)self.textColor=textColor or self.textColor self.bgColor=bgColor or self.bgColor if self.gui then self.gui:draw()end return self end function Label:draw(canvas)for i=1,#self.text do local x=self.x+i-1 local y=self.y if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor canvas[y][x].char=self.text:sub(i,i)canvas[y][x].charColor=self.textColor end end end return Label end local Label=components_Label()local function components_KeyHandler()local KeyHandler={}KeyHandler.__index=KeyHandler function KeyHandler:new()local obj=setmetatable({},self)obj.keyMappings={}return obj end function KeyHandler:registerKey(key,action)self.keyMappings[key]=action end function KeyHandler:handleKey(key)if self.keyMappings[key]then self.keyMappings[key]()end end return KeyHandler end local KeyHandler=components_KeyHandler()local function components_Textarea()local Textarea={}Textarea.__index=Textarea function Textarea:new(x,y,width,height,bgColor,textColor)if type(x)=="table" then local params=x x=params.x y=params.y width=params.width height=params.height bgColor=params.bgColor textColor=params.textColor end local obj=setmetatable({},self)obj.x=x or 1 obj.y=y or 1 obj.width=width or 10 obj.height=height or 5 obj.list={}obj.textList={}obj.active=false obj.bgColor=bgColor or colors.white obj.textColor=textColor or colors.black obj.scrollOffset=0 return obj end function Textarea:setPosition(x,y)self.x=x or self.x self.y=y or self.y return self end function Textarea:setSize(width,height)self.width=width or self.width self.height=height or self.height self:updateTextList()return self end function Textarea:setColors(bgColor,textColor)self.bgColor=bgColor or self.bgColor self.textColor=textColor or self.textColor return self end function Textarea:draw(canvas)for i=1,self.height do local y=self.y+i-1 local line=self.textList[i+self.scrollOffset]or "" for j=1,self.width do local x=self.x+j-1 if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor canvas[y][x].char=line:sub(j,j)~="" and line:sub(j,j)or " " canvas[y][x].charColor=self.textColor end end end end function Textarea:updateTextList()self.textList={}for _,line in ipairs(self.list)do while#line>self.width do table.insert(self.textList,line:sub(1,self.width))line=line:sub(self.width+1)end table.insert(self.textList,line)end self.scrollOffset=math.max(0,#self.textList-self.height)end function Textarea:setText(newText)self.list={}for line in newText:gmatch("[^\r\n]+")do table.insert(self.list,line)end self:updateTextList()if self.gui then self.gui:draw()end return self end function Textarea:addLine(line)table.insert(self.list,line)self:updateTextList()if self.gui then self.gui:draw()end return self end function Textarea:scrollUp()if self.scrollOffset>0 then self.scrollOffset=self.scrollOffset-1 if self.gui then self.gui:draw()end end end function Textarea:scrollDown()if self.scrollOffset<#self.textList-self.height then self.scrollOffset=self.scrollOffset+1 if self.gui then self.gui:draw()end end end function Textarea:isMouseOver(mx,my)return mx>=self.x and mx<self.x+self.width and my>=self.y and my<self.y+self.height end return Textarea end local Textarea=components_Textarea()local function components_Rect()local Rect={}Rect.__index=Rect function Rect:new(x,y,width,height,bgColor,fill,char,charColor)if type(x)=="table" then local params=x x=params.x y=params.y width=params.width height=params.height bgColor=params.bgColor fill=params.fill char=params.char charColor=params.charColor end local obj=setmetatable({},self)obj.x=x or 0 obj.y=y or 0 obj.width=width or 1 obj.height=height or 1 obj.bgColor=bgColor or colors.gray obj.fill=fill or false obj.char=char or " " obj.charColor=charColor or colors.white return obj end function Rect:setPosition(x,y)self.x=x or self.x self.y=y or self.y return self end function Rect:setSize(width,height)self.width=width or self.width self.height=height or self.height return self end function Rect:setColors(bgColor,charColor)self.bgColor=bgColor or self.bgColor self.charColor=charColor or self.charColor return self end function Rect:setChar(char)self.char=char or self.char return self end function Rect:setFill(fill)self.fill=fill or self.fill return self end function Rect:draw(canvas)for i=0,self.height-1 do for j=0,self.width-1 do if self.fill or i==0 or i==self.height-1 or j==0 or j==self.width-1 then local x=self.x+j local y=self.y+i if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor canvas[y][x].char=self.char canvas[y][x].charColor=self.charColor end end end end end return Rect end local Rect=components_Rect()local function components_Dropdown()local Dropdown={}Dropdown.__index=Dropdown function Dropdown:new(x,y,width,items,bgColor,textColor)if type(x)=="table" then local params=x x=params.x y=params.y width=params.width items=params.items bgColor=params.bgColor textColor=params.textColor end local obj=setmetatable({},self)obj.x=x or 0 obj.y=y or 0 obj.width=width or 10 obj.items=items or{}obj.selectedIndex=1 obj.expanded=false obj.bgColor=bgColor or colors.gray obj.textColor=textColor or colors.white obj.scrollOffset=0 return obj end function Dropdown:setPosition(x,y)self.x=x or self.x self.y=y or self.y return self end function Dropdown:setSize(width)self.width=width or self.width return self end function Dropdown:setItems(items)self.items=items or self.items return self end function Dropdown:setColors(bgColor,textColor)self.bgColor=bgColor or self.bgColor self.textColor=textColor or self.textColor return self end function Dropdown:draw(canvas)local function truncateText(text,maxLength)if#text<=maxLength then return text else local halfLength=math.floor((maxLength-2)/2)return text:sub(1,halfLength)..".."..text:sub(-halfLength)end end for i=1,self.width do local x=self.x+i-1 local y=self.y if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor if i==self.width then canvas[y][x].char="V" else local truncatedItem=truncateText(self.items[self.selectedIndex],self.width-1)local char=truncatedItem:sub(i,i)canvas[y][x].char=char~="" and char or " " end canvas[y][x].charColor=self.textColor end end if self.expanded then local maxVisibleItems=math.min(#self.items,5)local winWidth,winHeight=self.gui.win.getSize()local startY=self.y+1 if self.y+maxVisibleItems>winHeight then startY=self.y-maxVisibleItems end for i=1,maxVisibleItems do local itemIndex=i+self.scrollOffset local y=startY+i-1 for j=1,self.width do local x=self.x+j-1 if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor local truncatedItem=truncateText(self.items[itemIndex],self.width)local char=truncatedItem:sub(j,j)canvas[y][x].char=char~="" and char or " " canvas[y][x].charColor=self.textColor end end end end end function Dropdown:handleClick(mx,my)if mx>=self.x and mx<self.x+self.width and my==self.y then self.expanded=not self.expanded elseif self.expanded and mx>=self.x and mx<self.x+self.width then local winWidth,winHeight=self.gui.win.getSize()local maxVisibleItems=math.min(#self.items,5)local startY=self.y+1 if self.y+maxVisibleItems>winHeight then startY=self.y-maxVisibleItems end if my>=startY and my<startY+maxVisibleItems then self.selectedIndex=my-startY+1+self.scrollOffset self.expanded=false else self.expanded=false end else self.expanded=false end end function Dropdown:handleScroll(direction)if self.expanded then if direction==-1 or direction==0 and self.scrollOffset>0 then self.scrollOffset=self.scrollOffset-1 elseif direction==1 and self.scrollOffset<#self.items-5 then self.scrollOffset=self.scrollOffset+1 end end end function Dropdown:handleKey(key)if self.expanded then if key==keys.up and self.scrollOffset>0 then self.scrollOffset=self.scrollOffset-1 elseif key==keys.down and self.scrollOffset<#self.items-5 then self.scrollOffset=self.scrollOffset+1 elseif key==keys.enter then self.selectedIndex=self.scrollOffset+1 self.expanded=false end end end function Dropdown:isExpanded()return self.expanded end function Dropdown:getSelectedOption()return self.items[self.selectedIndex]end return Dropdown end local Dropdown=components_Dropdown()local function components_Switch()local Switch={}Switch.__index=Switch function Switch:new(x,y,state,callback,activeText,inactiveText,activeBgColor,inactiveBgColor,activeTextColor,inactiveTextColor)if type(x)=="table" then local params=x x=params.x y=params.y state=params.state callback=params.callback activeText=params.activeText inactiveText=params.inactiveText activeBgColor=params.activeBgColor inactiveBgColor=params.inactiveBgColor activeTextColor=params.activeTextColor inactiveTextColor=params.inactiveTextColor end local obj=setmetatable({},self)obj.x=x or 0 obj.y=y or 0 obj.state=state or false obj.callback=callback obj.activeBgColor=activeBgColor or colors.green obj.inactiveBgColor=inactiveBgColor or colors.red obj.activeTextColor=activeTextColor or colors.white obj.inactiveTextColor=inactiveTextColor or colors.white obj.activeText=activeText or "[ON]" obj.inactiveText=inactiveText or "[OFF]" return obj end function Switch:setPosition(x,y)self.x=x or self.x self.y=y or self.y return self end function Switch:setState(state)self.state=state return self end function Switch:setCallback(callback)self.callback=callback return self end function Switch:setColors(activeBgColor,inactiveBgColor,activeTextColor,inactiveTextColor)self.activeBgColor=activeBgColor or self.activeBgColor self.inactiveBgColor=inactiveBgColor or self.inactiveBgColor self.activeTextColor=activeTextColor or self.activeTextColor self.inactiveTextColor=inactiveTextColor or self.inactiveTextColor return self end function Switch:setTexts(activeText,inactiveText)self.activeText=activeText or self.activeText self.inactiveText=inactiveText or self.inactiveText return self end function Switch:draw(canvas)self.width=self.state and#self.activeText or#self.inactiveText for i=0,self.width-1 do local x=self.x+i local y=self.y if canvas[y]and canvas[y][x]then if self.state then canvas[y][x].bgColor=self.activeBgColor canvas[y][x].charColor=self.activeTextColor canvas[y][x].char=self.activeText:sub(i+1,i+1)else canvas[y][x].bgColor=self.inactiveBgColor canvas[y][x].charColor=self.inactiveTextColor canvas[y][x].char=self.inactiveText:sub(i+1,i+1)end end end end function Switch:handleClick(x,y)if x>=self.x and x<self.x+self.width and y==self.y then self.state=not self.state if self.callback then self.callback(self.state)end end end return Switch end local Switch=components_Switch()local function components_Line()local Line={}Line.__index=Line function Line:new(x1,y1,x2,y2,color,bgColor,char)if type(x1)=="table" then local params=x1 x1=params.x1 y1=params.y1 x2=params.x2 y2=params.y2 color=params.color bgColor=params.bgColor char=params.char end local obj=setmetatable({},self)obj.x1=x1 or 0 obj.y1=y1 or 0 obj.x2=x2 or 0 obj.y2=y2 or 0 obj.color=color or colors.white obj.bgColor=bgColor or colors.black obj.char=char or "-" return obj end function Line:setCoordinates(x1,y1,x2,y2)self.x1=x1 or self.x1 self.y1=y1 or self.y1 self.x2=x2 or self.x2 self.y2=y2 or self.y2 return self end function Line:setColors(color,bgColor)self.color=color or self.color self.bgColor=bgColor or self.bgColor return self end function Line:setChar(char)self.char=char or self.char return self end function Line:draw(canvas)if self.y1==self.y2 then for x=self.x1,self.x2 do if canvas[self.y1]and canvas[self.y1][x]then canvas[self.y1][x].bgColor=self.bgColor canvas[self.y1][x].char=self.char canvas[self.y1][x].charColor=self.color end end elseif self.x1==self.x2 then for y=self.y1,self.y2 do if canvas[y]and canvas[y][self.x1]then canvas[y][self.x1].bgColor=self.bgColor canvas[y][self.x1].char=self.char canvas[y][self.x1].charColor=self.color end end else local dx=math.abs(self.x2-self.x1)local dy=math.abs(self.y2-self.y1)local sx=self.x1<self.x2 and 1 or-1 local sy=self.y1<self.y2 and 1 or-1 local err=dx-dy local x=self.x1 local y=self.y1 while true do if canvas[y]and canvas[y][x]then canvas[y][x].bgColor=self.bgColor canvas[y][x].char=self.char canvas[y][x].charColor=self.color end if x==self.x2 and y==self.y2 then break end local e2=2*err if e2>-dy then err=err-dy x=x+sx end if e2<dx then err=err+dx y=y+sy end end end end return Line end local Line=components_Line()local function components_Circle()local Circle={}Circle.__index=Circle function Circle:new(x1,y1,x2,y2,color,fill,char,charColor)if type(x1)=="table" then local params=x1 x1=params.x1 y1=params.y1 x2=params.x2 y2=params.y2 color=params.color fill=params.fill char=params.char charColor=params.charColor end local obj=setmetatable({},self)obj.x1=x1 or 0 obj.y1=y1 or 0 obj.x2=x2 or 5 obj.y2=y2 or 5 obj.color=color or colors.white obj.fill=fill or false obj.char=char or " " obj.charColor=charColor or colors.white obj.pixels={}obj:update()return obj end function Circle:setPosition(x1,y1,x2,y2)self.x1=x1 or self.x1 self.y1=y1 or self.y1 self.x2=x2 or self.x2 self.y2=y2 or self.y2 self:update()return self end function Circle:setColors(color,charColor)self.color=color or self.color self.charColor=charColor or self.charColor return self end function Circle:setFill(fill)self.fill=fill or self.fill self:update()return self end function Circle:setChar(char)self.char=char or self.char return self end function Circle:update()local centerX=(self.x1+self.x2)/2 local centerY=(self.y1+self.y2)/2 local radiusX=math.abs(self.x2-self.x1)/2 local radiusY=math.abs(self.y2-self.y1)/2 local circumference=2*math.pi*math.min(radiusX,radiusY)local step=1/circumference self.pixels={}for theta=0,math.pi/2,step do local x=centerX+radiusX*math.cos(theta)local y=centerY+radiusY*math.sin(theta)table.insert(self.pixels,{math.floor(x+0.5),math.floor(y+0.5)})end local quarterPixels={}for _,pixel in ipairs(self.pixels)do table.insert(quarterPixels,{2*centerX-pixel[1],pixel[2]})table.insert(quarterPixels,{pixel[1],2*centerY-pixel[2]})table.insert(quarterPixels,{2*centerX-pixel[1],2*centerY-pixel[2]})end for _,pixel in ipairs(quarterPixels)do table.insert(self.pixels,pixel)end if self.fill then for y=self.y1,self.y2 do for x=self.x1,self.x2 do local dx=(x-centerX)/radiusX local dy=(y-centerY)/radiusY if dx*dx+dy*dy<=1 then table.insert(self.pixels,{x,y})end end end end end function Circle:draw(canvas)self.canvas=canvas for _,pixel in ipairs(self.pixels)do local x=pixel[1]local y=pixel[2]if self.canvas[y]and self.canvas[y][x]then self.canvas[y][x].bgColor=self.color self.canvas[y][x].char=self.char self.canvas[y][x].charColor=self.charColor end end end return Circle end local Circle=components_Circle()function GUI:new(x,y,width,height,parent)local termWidth,termHeight=term.getSize()x=x or 1 y=y or 1 width=width or termWidth height=height or termHeight local obj=setmetatable({},self)obj.win=window.create(parent or term.current(),x,y,width,height)obj.components={}obj.keyHandler=KeyHandler:new()obj.canvas={}for i=1,height do obj.canvas[i]={}for j=1,width do obj.canvas[i][j]={bgColor=colors.black,char=" ",charColor=colors.white}end end return obj end function GUI:addLabel(x,y,text,textColor)local label=Label:new(x,y,text,textColor)label.gui=self table.insert(self.components,label)return label end function GUI:addButton(x,y,label,callback,bgColor,textColor,width,height)local button=Button:new(x,y,label,callback,bgColor,textColor,width,height)button.gui=self table.insert(self.components,button)return button end function GUI:addInput(x,y,width,maxLength,bgColor,textColor,replaceChar,history,completeFn,default,callback,deactivateOnEnter)local input=Input:new(x,y,width,maxLength,bgColor,textColor,replaceChar,history,completeFn,default,callback,deactivateOnEnter)input.gui=self table.insert(self.components,input)return input end function GUI:addTextarea(x,y,width,height,bgColor,textColor)local textarea=Textarea:new(x,y,width,height,bgColor,textColor)textarea.gui=self table.insert(self.components,textarea)return textarea end function GUI:addRect(x,y,width,height,bgColor,fill,char,charColor)local rect=Rect:new(x,y,width,height,bgColor,fill,char,charColor)rect.gui=self table.insert(self.components,rect)return rect end function GUI:addDropdown(x,y,width,items,bgColor,textColor)local dropdown=Dropdown:new(x,y,width,items,bgColor,textColor)dropdown.gui=self table.insert(self.components,dropdown)return dropdown end function GUI:addSwitch(x,y,state,callback,activeText,inactiveText,activeBgColor,inactiveBgColor,activeTextColor,inactiveTextColor)local switch=Switch:new(x,y,state,callback,activeText,inactiveText,activeBgColor,inactiveBgColor,activeTextColor,inactiveTextColor)switch.gui=self table.insert(self.components,switch)return switch end function GUI:addLine(x1,y1,x2,y2,color,bgColor,char)local line=Line:new(x1,y1,x2,y2,color,bgColor,char)line.gui=self table.insert(self.components,line)return line end function GUI:addCircle(x1,y1,x2,y2,color,fill,char,charColor)local circle=Circle:new(x1,y1,x2,y2,color,fill,char,charColor)circle.gui=self table.insert(self.components,circle)return circle end function GUI:addKeyHandler()return self.keyHandler end function GUI:draw()local win=self.win for y,row in ipairs(self.canvas)do for x,_ in ipairs(row)do self.canvas[y][x]={bgColor=colors.black,char=" ",charColor=colors.white}end end for _,comp in ipairs(self.components)do if comp.draw then comp:draw(self.canvas)end end for y,row in ipairs(self.canvas)do for x,pixel in ipairs(row)do win.setCursorPos(x,y)win.setBackgroundColor(pixel.bgColor)win.setTextColor(pixel.charColor)win.write(pixel.char)end end win.redraw()end function GUI:handleClick(x,y)for _,comp in ipairs(self.components)do if getmetatable(comp)==Dropdown and comp:isExpanded()then comp:handleClick(x,y)return end end for _,comp in ipairs(self.components)do if comp.handleClick then comp:handleClick(x,y)end end end function GUI:handleKey(key)for _,comp in ipairs(self.components)do if getmetatable(comp)==Input and comp.active then return elseif getmetatable(comp)==Dropdown and comp.expanded then comp:handleKey(key)return end end self.keyHandler:handleKey(key)end function GUI:update(event,param1,param2,param3)if event=="mouse_click" then self:handleClick(param2,param3)elseif event=="key" or event=="char" then self:handleKey(param1)for _,comp in ipairs(self.components)do if comp.handleInput then comp:handleInput(event,param1)elseif getmetatable(comp)==Textarea then if param1==keys.up then comp:scrollUp()elseif param1==keys.down then comp:scrollDown()end end end elseif event=="mouse_scroll" then for _,comp in ipairs(self.components)do if getmetatable(comp)==Dropdown and comp.expanded then comp:handleScroll(param1)elseif getmetatable(comp)==Textarea and comp:isMouseOver(param2,param3)then if param1==-1 then comp:scrollUp()elseif param1==1 then comp:scrollDown()end end end end self:draw()end function GUI:run(...)parallel.waitForAny(function()while true do local event,param1,param2,param3=os.pullEvent()self:update(event,param1,param2,param3)end end)end return GUI end local kolos=KolOS()local completion=require "cc.completion" local gui=kolos:new()local label=gui:addLabel():setPosition(2,2):setText("Hello, World!"):setColors(colors.white)local textarea=gui:addTextarea():setPosition(2,8):setSize(20,5):setColors(colors.gray,colors.white)local input=gui:addInput():setPosition(2,6):setSize(20,100):setColors(colors.gray,colors.white):setHistory({'scam','aboba'}):setCompleteFn(function(text)return completion.choice(text,{"scam","aboba","abbba","ababa","abiba","aboba","abuba"})end):setCallback(function(text)textarea:addLine("> "..text)end):setDeactivateOnEnter(false)local rect=gui:addRect():setPosition(30,5):setSize(10,5):setColors(colors.blue):setFill(true)local button=gui:addButton():setPosition(2,4):setLabel("Click Me"):addCallback(function()textarea:addLine("> "..input.text)end)local dropdown=gui:addDropdown():setPosition(2,14):setSize(20):setItems({"Option 1","Option 2","Option 3","Option 4","Option 5","Option 6","Option 7"}):setColors(colors.gray,colors.white)local switch=gui:addSwitch():setPosition(2,16):setState(false):setCallback(function(state)label:setText("Switch state: "..tostring(state))end):setTexts("ON","OFF"):setColors(colors.green,colors.red,colors.white,colors.white)local line=gui:addLine():setCoordinates(29,4,40,10):setColors(colors.yellow,colors.black):setChar("V")local circle=gui:addCircle():setPosition(31,6,38,8):setColors(colors.red):setFill(true)local ok,error=pcall(function()parallel.waitForAny(function()while true do local event,param1,param2,param3=os.pullEvent()l={}for index,value in ipairs({event,param1,param2,param3})do table.insert(l,tostring(value))end gui:update(event,param1,param2,param3)end end)end)term.clear()term.setCursorPos(1,1)if not ok then printError(error)end 